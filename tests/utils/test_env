#!/bin/bash

# DataFlow PostgreSQL Test Environment Manager
# Manages Docker PostgreSQL container for testing with NO MOCKING policy

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CONTAINER_NAME="dataflow_test_postgres"
POSTGRES_PORT=5434
POSTGRES_DB="kailash_test"
POSTGRES_USER="test_user"
POSTGRES_PASSWORD="test_password"

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

check_docker() {
    if ! command -v docker &> /dev/null; then
        log_error "Docker is not installed or not in PATH"
        exit 1
    fi

    if ! docker info &> /dev/null; then
        log_error "Docker daemon is not running"
        exit 1
    fi
}

start_postgres() {
    log_info "Starting PostgreSQL test container..."

    # Check if container already exists
    if docker ps -a --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
        log_info "Container ${CONTAINER_NAME} already exists"

        # Check if running
        if docker ps --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
            log_success "PostgreSQL container already running"
            return 0
        else
            log_info "Starting existing container..."
            docker start ${CONTAINER_NAME}
        fi
    else
        log_info "Creating new PostgreSQL container..."
        docker run -d \
            --name ${CONTAINER_NAME} \
            -e POSTGRES_DB=${POSTGRES_DB} \
            -e POSTGRES_USER=${POSTGRES_USER} \
            -e POSTGRES_PASSWORD=${POSTGRES_PASSWORD} \
            -e POSTGRES_HOST_AUTH_METHOD=trust \
            -p ${POSTGRES_PORT}:5432 \
            postgres:15-alpine
    fi

    # Wait for PostgreSQL to be ready
    log_info "Waiting for PostgreSQL to be ready..."
    max_attempts=30
    attempt=0

    while [ $attempt -lt $max_attempts ]; do
        if docker exec ${CONTAINER_NAME} pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB} &> /dev/null; then
            log_success "PostgreSQL is ready!"
            return 0
        fi

        attempt=$((attempt + 1))
        echo -n "."
        sleep 1
    done

    echo ""
    log_error "PostgreSQL failed to start within ${max_attempts} seconds"
    return 1
}

stop_postgres() {
    log_info "Stopping PostgreSQL test container..."

    if docker ps --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
        docker stop ${CONTAINER_NAME}
        log_success "PostgreSQL container stopped"
    else
        log_warning "PostgreSQL container is not running"
    fi
}

remove_postgres() {
    log_info "Removing PostgreSQL test container..."

    # Stop if running
    if docker ps --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
        docker stop ${CONTAINER_NAME}
    fi

    # Remove if exists
    if docker ps -a --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
        docker rm ${CONTAINER_NAME}
        log_success "PostgreSQL container removed"
    else
        log_warning "PostgreSQL container does not exist"
    fi
}

show_status() {
    echo ""
    echo "=== DataFlow Test Environment Status ==="
    echo ""

    # Docker status
    if command -v docker &> /dev/null && docker info &> /dev/null; then
        log_success "Docker: Ready"
    else
        log_error "Docker: Not available"
        return 1
    fi

    # Container status
    if docker ps -a --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
        if docker ps --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
            log_success "PostgreSQL Container: Running"
        else
            log_warning "PostgreSQL Container: Stopped"
            return 1
        fi
    else
        log_error "PostgreSQL Container: Not found"
        return 1
    fi

    # Database connectivity
    if docker exec ${CONTAINER_NAME} pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB} &> /dev/null; then
        log_success "PostgreSQL Database: Ready"
    else
        log_error "PostgreSQL Database: Not ready"
        return 1
    fi

    # Connection info
    echo ""
    echo "Connection Details:"
    echo "  Host: localhost"
    echo "  Port: ${POSTGRES_PORT}"
    echo "  Database: ${POSTGRES_DB}"
    echo "  User: ${POSTGRES_USER}"
    echo "  Password: ${POSTGRES_PASSWORD}"
    echo ""
    echo "Connection URL:"
    echo "  postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@localhost:${POSTGRES_PORT}/${POSTGRES_DB}"
    echo ""

    log_success "All services ready for testing!"
    return 0
}

cleanup_data() {
    log_info "Cleaning test data..."

    if ! docker ps --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
        log_error "PostgreSQL container is not running"
        return 1
    fi

    # Drop all tables in public schema
    docker exec ${CONTAINER_NAME} psql -U ${POSTGRES_USER} -d ${POSTGRES_DB} -c "
        DO \$\$ DECLARE
            r RECORD;
        BEGIN
            FOR r IN (SELECT tablename FROM pg_tables WHERE schemaname = 'public') LOOP
                EXECUTE 'DROP TABLE IF EXISTS ' || quote_ident(r.tablename) || ' CASCADE';
            END LOOP;
        END \$\$;
    " &> /dev/null

    log_success "Test data cleaned"
}

run_tests() {
    local test_tier=$1
    local test_path=$2

    log_info "Running ${test_tier} tests..."

    # Ensure PostgreSQL is running
    if ! show_status &> /dev/null; then
        log_error "Test environment not ready. Run './test-env up' first."
        return 1
    fi

    cd "${SCRIPT_DIR}/../.."

    case $test_tier in
        "unit")
            log_info "Running Tier 1 Unit Tests (<1 second each)"
            python -m pytest tests/unit/test_schema_state_manager_postgresql_fixes.py -v --timeout=1 --tb=short
            ;;
        "integration")
            log_info "Running Tier 2 Integration Tests (<5 seconds each)"
            python -m pytest tests/integration/test_postgresql_migration_system_integration.py -v --timeout=5 --tb=short
            ;;
        "e2e")
            log_info "Running Tier 3 E2E Tests (<10 seconds each)"
            python -m pytest tests/e2e/test_dataflow_migration_complete_user_journey.py -v --timeout=10 --tb=short
            ;;
        "all")
            log_info "Running All Tiers (Unit -> Integration -> E2E)"
            python -m pytest tests/unit/test_schema_state_manager_postgresql_fixes.py -v --timeout=1 --tb=short && \
            python -m pytest tests/integration/test_postgresql_migration_system_integration.py -v --timeout=5 --tb=short && \
            python -m pytest tests/e2e/test_dataflow_migration_complete_user_journey.py -v --timeout=10 --tb=short
            ;;
        *)
            if [ -n "$test_path" ]; then
                python -m pytest "$test_path" -v --tb=short
            else
                log_error "Invalid test tier: $test_tier"
                echo "Valid tiers: unit, integration, e2e, all"
                return 1
            fi
            ;;
    esac
}

performance_test() {
    log_info "Running performance validation tests..."

    if ! show_status &> /dev/null; then
        log_error "Test environment not ready. Run './test-env up' first."
        return 1
    fi

    cd "${SCRIPT_DIR}/../.."

    # Run performance-focused tests
    python -m pytest tests/ -k "performance" -v --tb=short

    # Run schema operation timing tests
    python -c "
import asyncio
import time
from tests.utils.test_env_setup import get_test_connection, cleanup_test_data
from dataflow.migrations.schema_state_manager import SchemaStateManager

async def test_performance():
    print('Testing PostgreSQL migration system performance...')

    await cleanup_test_data()
    conn = await get_test_connection()

    try:
        manager = SchemaStateManager(conn)

        # Test cache performance
        start = time.perf_counter()
        for i in range(100):
            schema = manager._fetch_fresh_schema()
        cache_time = (time.perf_counter() - start) * 1000

        print(f'100 schema fetches: {cache_time:.2f}ms ({cache_time/100:.2f}ms avg)')

        if cache_time/100 < 100:
            print('✅ Cache performance: PASS (<100ms avg)')
        else:
            print('❌ Cache performance: FAIL (>100ms avg)')

    finally:
        await conn.close()

asyncio.run(test_performance())
    "
}

show_help() {
    echo ""
    echo "DataFlow PostgreSQL Test Environment Manager"
    echo ""
    echo "USAGE:"
    echo "  ./test-env COMMAND [OPTIONS]"
    echo ""
    echo "COMMANDS:"
    echo "  up              Start PostgreSQL test container"
    echo "  down            Stop PostgreSQL test container"
    echo "  remove          Remove PostgreSQL test container"
    echo "  status          Show test environment status"
    echo "  clean           Clean all test data from database"
    echo "  test TIER       Run tests by tier (unit|integration|e2e|all)"
    echo "  performance     Run performance validation tests"
    echo "  help            Show this help message"
    echo ""
    echo "EXAMPLES:"
    echo "  ./test-env up                    # Start test environment"
    echo "  ./test-env status                # Check if ready"
    echo "  ./test-env test unit             # Run unit tests"
    echo "  ./test-env test integration      # Run integration tests"
    echo "  ./test-env test e2e              # Run E2E tests"
    echo "  ./test-env test all              # Run all test tiers"
    echo "  ./test-env performance           # Run performance tests"
    echo "  ./test-env clean                 # Clean test data"
    echo "  ./test-env down                  # Stop test environment"
    echo ""
    echo "TEST TIERS:"
    echo "  Tier 1 (Unit):        Isolated components, <1s timeout, no external deps"
    echo "  Tier 2 (Integration): Real PostgreSQL, <5s timeout, NO MOCKING"
    echo "  Tier 3 (E2E):         Complete scenarios, <10s timeout, full workflow"
    echo ""
}

# Main command handling
case "${1:-help}" in
    "up")
        check_docker
        start_postgres
        show_status
        ;;
    "down")
        check_docker
        stop_postgres
        ;;
    "remove")
        check_docker
        remove_postgres
        ;;
    "status")
        check_docker
        show_status
        ;;
    "clean")
        check_docker
        cleanup_data
        ;;
    "test")
        check_docker
        run_tests "$2" "$3"
        ;;
    "performance")
        check_docker
        performance_test
        ;;
    "help"|"--help"|"-h")
        show_help
        ;;
    *)
        log_error "Unknown command: $1"
        show_help
        exit 1
        ;;
esac
