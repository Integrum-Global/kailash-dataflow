# Migration Guide: DataFlow v0.5.x to v0.6.0

**Date**: 2025-10-22
**Affected Versions**: v0.5.0 through v0.5.6 ‚Üí v0.6.0+
**Migration Difficulty**: ‚≠ê EASY (100% backward compatible)

---

## Overview

DataFlow v0.6.0 introduces a clearer, more intuitive API for CRUD and bulk operations while maintaining **100% backward compatibility** with existing code. You can upgrade immediately without making any changes, then migrate to the new API at your own pace.

### What Changed?

**Parameter names are more intuitive**:
- `conditions` ‚Üí `filter` (more descriptive of what it does)
- `updates` ‚Üí `fields` (clearer that you're specifying field values)
- `update` ‚Üí `fields` (in bulk operations)

### Why the Change?

The new parameter names better reflect their purpose:
- **`filter`**: Clearly indicates "filter criteria to match records"
- **`fields`**: Clearly indicates "field values to update"

The old names (`conditions`, `updates`) were less intuitive and sometimes confused with other concepts.

---

## Do You Need to Migrate?

### ‚úÖ No Immediate Action Required

Your existing code will continue to work **without any changes**. DataFlow v0.6.0 is 100% backward compatible.

### üìÖ Recommended Migration Timeline

- **Immediate** (v0.6.0 - v0.7.x): Old API fully supported, deprecation warnings added
- **Future** (v0.8.0): Old API will be removed (breaking change)

**Recommendation**: Migrate to the new API gradually to avoid rushing when v0.8.0 is released.

---

## Migration Checklist

### 1. UpdateNode

#### Old API (v0.5.x)
```python
workflow.add_node("UserUpdateNode", "update_user", {
    "conditions": {"id": user_id},
    "updates": {"name": "Alice Updated"}
})
```

#### New API (v0.6.0+)
```python
workflow.add_node("UserUpdateNode", "update_user", {
    "filter": {"id": user_id},
    "fields": {"name": "Alice Updated"}
})
```

**Changes**:
- `conditions` ‚Üí `filter`
- `updates` ‚Üí `fields`

---

### 2. DeleteNode

#### Old API (v0.5.x)
```python
workflow.add_node("UserDeleteNode", "delete_user", {
    "conditions": {"active": False}
})
```

#### New API (v0.6.0+)
```python
workflow.add_node("UserDeleteNode", "delete_user", {
    "filter": {"active": False}
})
```

**Changes**:
- `conditions` ‚Üí `filter`

---

### 3. BulkUpdateNode

#### Old API (v0.5.x)
```python
workflow.add_node("UserBulkUpdateNode", "bulk_update", {
    "conditions": {"active": True},
    "update": {"status": "verified"}
})
```

#### New API (v0.6.0+)
```python
workflow.add_node("UserBulkUpdateNode", "bulk_update", {
    "filter": {"active": True},
    "fields": {"status": "verified"}
})
```

**Changes**:
- `conditions` ‚Üí `filter`
- `update` ‚Üí `fields`

---

### 4. BulkDeleteNode

#### Old API (v0.5.x)
```python
workflow.add_node("UserBulkDeleteNode", "bulk_delete", {
    "conditions": {"active": False}
})
```

#### New API (v0.6.0+)
```python
workflow.add_node("UserBulkDeleteNode", "bulk_delete", {
    "filter": {"active": False}
})
```

**Changes**:
- `conditions` ‚Üí `filter`

---

## Deprecation Warnings

When you use the old API (v0.6.0+), you'll see deprecation warnings:

```python
DeprecationWarning: Parameter 'conditions' is deprecated in UpdateNode and will be removed in v0.8.0. Use 'filter' instead.

DeprecationWarning: Parameter 'updates' is deprecated in UpdateNode and will be removed in v0.8.0. Use 'fields' instead.
```

**These are informational only** - your code will continue to work perfectly.

---

## Migration Strategies

### Strategy 1: Gradual Migration (Recommended)

Migrate one node type at a time across your codebase:

#### Week 1: UpdateNode
Find and replace in your codebase:
```bash
# Find all UpdateNode instances
grep -r "UserUpdateNode\|.*UpdateNode" . --include="*.py"

# Update each one from conditions/updates to filter/fields
```

#### Week 2: DeleteNode
```bash
# Find all DeleteNode instances
grep -r "UserDeleteNode\|.*DeleteNode" . --include="*.py"

# Update from conditions to filter
```

#### Week 3: Bulk Operations
```bash
# Find all BulkUpdateNode and BulkDeleteNode instances
grep -r "BulkUpdateNode\|BulkDeleteNode" . --include="*.py"
```

### Strategy 2: All at Once

Use find-and-replace with your IDE or `sed`:

```bash
# UpdateNode: conditions ‚Üí filter
find . -name "*.py" -type f -exec sed -i '' 's/"conditions":/"filter":/g' {} \;

# UpdateNode: updates ‚Üí fields
find . -name "*.py" -type f -exec sed -i '' 's/"updates":/"fields":/g' {} \;

# BulkUpdateNode: update ‚Üí fields
find . -name "*.py" -type f -exec sed -i '' 's/"update":/"fields":/g' {} \;
```

**‚ö†Ô∏è Warning**: Test thoroughly after bulk replacements to ensure you didn't accidentally change unrelated code.

### Strategy 3: Hybrid Approach

Keep old API for stable code, use new API for new features:

```python
# Existing code - leave as-is for now
workflow.add_node("UserUpdateNode", "update_user", {
    "conditions": {"id": user_id},
    "updates": {"name": "Alice Updated"}
})

# New features - use new API
workflow.add_node("UserUpdateNode", "update_user_v2", {
    "filter": {"id": user_id},
    "fields": {"name": "Alice Updated"}
})
```

Migrate gradually as you touch each file.

---

## Common Migration Patterns

### Pattern 1: Complex Filters

#### Old API
```python
workflow.add_node("UserUpdateNode", "update_users", {
    "conditions": {
        "age": {"$gte": 18, "$lte": 65},
        "active": True,
        "created_at": {"$gte": "2024-01-01"}
    },
    "updates": {
        "status": "verified",
        "verified_at": datetime.now()
    }
})
```

#### New API
```python
workflow.add_node("UserUpdateNode", "update_users", {
    "filter": {
        "age": {"$gte": 18, "$lte": 65},
        "active": True,
        "created_at": {"$gte": "2024-01-01"}
    },
    "fields": {
        "status": "verified",
        "verified_at": datetime.now()
    }
})
```

### Pattern 2: Multiple Fields Update

#### Old API
```python
workflow.add_node("UserUpdateNode", "update_profile", {
    "conditions": {"id": user_id},
    "updates": {
        "name": "John Smith",
        "email": "john.smith@example.com",
        "age": 31,
        "updated_at": datetime.now()
    }
})
```

#### New API
```python
workflow.add_node("UserUpdateNode", "update_profile", {
    "filter": {"id": user_id},
    "fields": {
        "name": "John Smith",
        "email": "john.smith@example.com",
        "age": 31,
        "updated_at": datetime.now()
    }
})
```

### Pattern 3: Bulk Operations

#### Old API
```python
# Bulk update
workflow.add_node("UserBulkUpdateNode", "bulk_verify", {
    "conditions": {"status": "pending", "email_verified": True},
    "update": {"status": "active"}
})

# Bulk delete
workflow.add_node("UserBulkDeleteNode", "bulk_cleanup", {
    "conditions": {"active": False, "last_login": {"$lt": "2023-01-01"}}
})
```

#### New API
```python
# Bulk update
workflow.add_node("UserBulkUpdateNode", "bulk_verify", {
    "filter": {"status": "pending", "email_verified": True},
    "fields": {"status": "active"}
})

# Bulk delete
workflow.add_node("UserBulkDeleteNode", "bulk_cleanup", {
    "filter": {"active": False, "last_login": {"$lt": "2023-01-01"}}
})
```

---

## Testing Your Migration

### 1. Run Your Test Suite

```bash
# Run all tests
pytest

# Run specific CRUD tests
pytest tests/ -k "crud or update or delete"
```

### 2. Check for Deprecation Warnings

```bash
# Run with warnings enabled
python -W default::DeprecationWarning your_script.py

# Or in pytest
pytest -W default::DeprecationWarning
```

### 3. Verify Functionality

Create a simple test script:

```python
from dataflow import DataFlow
from kailash.workflow.builder import WorkflowBuilder
from kailash.runtime.local import LocalRuntime

db = DataFlow(":memory:")

@db.model
class User:
    name: str
    email: str

# Test new API
workflow = WorkflowBuilder()
workflow.add_node("UserCreateNode", "create", {"name": "Alice", "email": "alice@example.com"})
workflow.add_node("UserUpdateNode", "update", {
    "filter": {"id": 1},
    "fields": {"name": "Alice Updated"}
})

runtime = LocalRuntime()
results, run_id = runtime.execute(workflow.build())

assert results["update"]["name"] == "Alice Updated"
print("‚úÖ Migration successful!")
```

---

## Benefits of Migrating

### 1. Clearer Code

**Before**:
```python
"conditions": {"id": user_id},  # What kind of conditions?
"updates": {"name": "Alice"}     # Updates to what?
```

**After**:
```python
"filter": {"id": user_id},  # Clear: filtering records
"fields": {"name": "Alice"}  # Clear: updating field values
```

### 2. Better IDE Support

More descriptive parameter names improve autocomplete and documentation tooltips.

### 3. Easier Onboarding

New developers will find the API more intuitive and self-documenting.

### 4. Future-Proof

Avoid rushed migration when v0.8.0 removes the old API.

---

## Troubleshooting

### Issue: "Both 'filter' and 'conditions' provided"

**Problem**: You accidentally used both old and new parameters.

```python
workflow.add_node("UserUpdateNode", "update", {
    "conditions": {"id": 1},  # Old API
    "filter": {"id": 1},       # New API - will take precedence
    "fields": {"name": "Alice"}
})
```

**Solution**: Use only the new API:

```python
workflow.add_node("UserUpdateNode", "update", {
    "filter": {"id": 1},
    "fields": {"name": "Alice"}
})
```

### Issue: "Parameter silently ignored"

**Problem**: Typo in parameter name.

```python
workflow.add_node("UserUpdateNode", "update", {
    "filters": {"id": 1},  # Typo: should be 'filter'
    "field": {"name": "Alice"}  # Typo: should be 'fields'
})
```

**Solution**: Use exact parameter names:

```python
workflow.add_node("UserUpdateNode", "update", {
    "filter": {"id": 1},   # Correct
    "fields": {"name": "Alice"}  # Correct
})
```

---

## FAQ

### Q: Do I need to migrate immediately?

**A**: No. Your existing code will continue to work without changes through v0.7.x.

### Q: Will my code break if I don't migrate?

**A**: Not until v0.8.0 (future release). You have plenty of time.

### Q: Can I use both old and new APIs in the same codebase?

**A**: Yes! You can migrate gradually. If both are provided, the new API takes precedence.

### Q: What happens if I provide both old and new parameters?

**A**: The new API parameters (`filter`/`fields`) take precedence. You'll see a deprecation warning for the old ones.

### Q: Are there performance differences?

**A**: No. Both APIs use the same underlying implementation. Performance is identical.

### Q: Will my tests need updating?

**A**: Only if they check for specific parameter names. Functionality remains the same.

---

## Migration Checklist

- [ ] **Backup your code** (commit to git)
- [ ] **Update to DataFlow v0.6.0+**
- [ ] **Run existing tests** (verify nothing broke)
- [ ] **Choose migration strategy** (gradual, all-at-once, or hybrid)
- [ ] **Migrate UpdateNode instances** (`conditions`‚Üí`filter`, `updates`‚Üí`fields`)
- [ ] **Migrate DeleteNode instances** (`conditions`‚Üí`filter`)
- [ ] **Migrate BulkUpdateNode instances** (`conditions`‚Üí`filter`, `update`‚Üí`fields`)
- [ ] **Migrate BulkDeleteNode instances** (`conditions`‚Üí`filter`)
- [ ] **Run tests again** (verify migrations work)
- [ ] **Check for deprecation warnings**
- [ ] **Update documentation/comments** in your code
- [ ] **Review with team** (if applicable)
- [ ] **Deploy to staging** (test in production-like environment)
- [ ] **Deploy to production**

---

## Need Help?

- **Documentation**: Check the [CRUD Operations Guide](../development/crud.md)
- **Examples**: See updated examples in `/examples` directory
- **Issues**: Report problems at https://github.com/yourusername/dataflow/issues
- **Community**: Ask questions in our community forum

---

## Summary

‚úÖ **100% backward compatible** - No immediate action required
‚úÖ **Gradual migration** - Update at your own pace
‚úÖ **Clear benefits** - More intuitive API, better documentation
‚úÖ **Future-proof** - Prepare for v0.8.0 in advance

**Recommended Action**: Start migrating gradually, beginning with UpdateNode instances in new features or files you're actively working on.

---

**Last Updated**: 2025-10-22
**DataFlow Version**: v0.6.0+
